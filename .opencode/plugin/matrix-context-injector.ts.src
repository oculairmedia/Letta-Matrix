import type { Plugin } from "@opencode-ai/plugin";
import { existsSync } from "fs";
import { readFile, unlink, writeFile } from "fs/promises";
import path from "path";
import { loadMatrixConfig } from "./lib/matrix-config";
import { resolveMatrixCredentials } from "./lib/matrix-credentials";
import { MatrixSyncClient, type MatrixMessage } from "./lib/matrix-sync-client";

const DEDUPE_TTL_MS = 60 * 60 * 1000;
const DEDUPE_CLEANUP_MS = 60 * 1000;

class DedupeCache {
  private entries = new Map<string, number>();
  private interval: NodeJS.Timeout;

  constructor(private ttlMs: number, cleanupMs: number) {
    this.interval = setInterval(() => this.cleanup(), cleanupMs);
  }

  has(key: string): boolean {
    const expiresAt = this.entries.get(key);
    if (!expiresAt) return false;
    if (expiresAt <= Date.now()) {
      this.entries.delete(key);
      return false;
    }
    return true;
  }

  add(key: string): void {
    this.entries.set(key, Date.now() + this.ttlMs);
  }

  stop(): void {
    clearInterval(this.interval);
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, expiresAt] of this.entries.entries()) {
      if (expiresAt <= now) {
        this.entries.delete(key);
      }
    }
  }
}

function getSessionUpdatedAtMs(session: any): number {
  const value = session?.time?.updated;
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
}

async function getActiveSessionId(client: any, targetDirectory: string): Promise<string | null> {
  try {
    const response = await client.session.list();
    const sessions = Array.isArray(response.data) ? response.data : [];

    const targetResolved = path.resolve(targetDirectory);
    const matching = sessions.filter((session: any) => {
      if (!session?.directory || typeof session.directory !== "string") return false;
      return path.resolve(session.directory) === targetResolved;
    });

    if (matching.length === 0) return null;

    const sorted = [...matching].sort(
      (a: any, b: any) => getSessionUpdatedAtMs(b) - getSessionUpdatedAtMs(a)
    );
    return sorted[0].id;
  } catch {
    return null;
  }
}

async function acquireLock(lockPath: string): Promise<void> {
  if (existsSync(lockPath)) {
    const contents = await readFile(lockPath, "utf-8").catch(() => "");
    if (contents) {
      try {
        const parsed = JSON.parse(contents) as { pid?: number };
        if (typeof parsed.pid === "number") {
          try {
            process.kill(parsed.pid, 0);
          } catch {
            await unlink(lockPath).catch(() => undefined);
          }
        }
      } catch {
      }
    }

    if (existsSync(lockPath)) {
      throw new Error(
        `Matrix injector already running. Remove lock at ${lockPath}. ${contents ? `Details: ${contents}` : ""}`
      );
    }
  }

  const payload = JSON.stringify({
    pid: process.pid,
    startedAt: new Date().toISOString(),
  });
  await writeFile(lockPath, payload, { flag: "wx" });
}

async function releaseLock(lockPath: string): Promise<void> {
  if (!existsSync(lockPath)) return;
  await unlink(lockPath).catch(() => undefined);
}

function formatInjection(message: MatrixMessage, label: string): string {
  return `[Matrix from ${message.displayName} in ${label}]
${message.body}`;
}

function stripReplyFallback(body: string): string {
  const lines = body.split("\n");
  if (lines.length === 0) return body;
  if (!lines[0].startsWith(">")) return body;

  for (let idx = 1; idx < lines.length; idx++) {
    if (lines[idx] === "" && lines[idx - 1].startsWith(">")) {
      const remainder = lines.slice(idx + 1).join("\n").trim();
      return remainder.length > 0 ? remainder : body;
    }
  }

  return body;
}

function extractOpenCodeMentions(body: string): string[] {
  const mentions = new Set<string>();

  const cleaned = stripReplyFallback(body);

  const fullMatches = cleaned.match(/@oc_[a-z0-9_]+(?:_v2)?:[a-z0-9._-]+/gi) ?? [];
  for (const match of fullMatches) mentions.add(match);

  const localMatches = cleaned.match(/@oc_[a-z0-9_]+(?:_v2)?/gi) ?? [];
  for (const match of localMatches) mentions.add(match);

  return [...mentions];
}

function messageMentionsIdentity(body: string, userId: string): boolean {
  const mentions = extractOpenCodeMentions(body);
  if (mentions.length === 0) return false;

  const normalizedUserId = userId.toLowerCase();
  const localpart = userId.split(":")[0]?.toLowerCase();

  return mentions.some((mention) => {
    const normalized = mention.toLowerCase();
    return normalized === normalizedUserId || (localpart ? normalized === localpart : false);
  });
}

const BRIDGE_URL = process.env.OPENCODE_BRIDGE_URL || "http://127.0.0.1:3201";
const HEARTBEAT_INTERVAL_MS = 2 * 60 * 1000;

async function registerWithBridge(
  directory: string,
  rooms: string[],
  sessionId: string
): Promise<string | null> {
  try {
    const response = await fetch(`${BRIDGE_URL}/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        port: 0,
        hostname: "127.0.0.1",
        sessionId,
        directory,
        rooms,
      }),
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { id?: string };
    return data.id || null;
  } catch {
    return null;
  }
}

async function sendHeartbeat(registrationId: string): Promise<boolean> {
  try {
    const response = await fetch(`${BRIDGE_URL}/heartbeat`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
    return response.ok;
  } catch {
    return false;
  }
}

async function unregisterFromBridge(registrationId: string): Promise<void> {
  try {
    await fetch(`${BRIDGE_URL}/unregister`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
  } catch {
    return;
  }
}

export const MatrixContextInjector: Plugin = async ({ client, directory, worktree }) => {
  const baseDir = worktree || directory;
  const lockPath = path.join(baseDir, ".opencode", "matrix.lock");
  const dedupe = new DedupeCache(DEDUPE_TTL_MS, DEDUPE_CLEANUP_MS);

  const log = (level: "debug" | "info" | "warn" | "error", message: string, extra?: any) => {
    client.app.log({
      body: {
        service: "matrix-context-injector",
        level,
        message,
        extra,
      },
    }).catch(() => undefined);
  };

  let syncClient: MatrixSyncClient | null = null;
  let bridgeRegistrationId: string | null = null;
  let heartbeatInterval: NodeJS.Timeout | null = null;

  const shutdown = () => {
    dedupe.stop();
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
    if (bridgeRegistrationId) {
      unregisterFromBridge(bridgeRegistrationId).catch(() => undefined);
      bridgeRegistrationId = null;
    }
    if (syncClient) {
      syncClient.stop().catch(() => undefined);
    }
    releaseLock(lockPath).catch(() => undefined);
  };

  process.on("exit", shutdown);
  process.on("SIGINT", () => {
    shutdown();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    shutdown();
    process.exit(0);
  });

  // Initialize in background - don't block plugin loading
  setTimeout(async () => {
    try {
      await acquireLock(lockPath);
    } catch (error: any) {
      log("error", error.message);
      client.tui.showToast({
        body: { message: error.message, variant: "error" },
      }).catch(() => undefined);
      return;
    }

    try {
      const config = await loadMatrixConfig(baseDir);
      const credentials = await resolveMatrixCredentials({
        directory,
        worktree: baseDir,
        homeserver: config.homeserver,
        userIdOverride: config.userId,
      });

      syncClient = new MatrixSyncClient({
        homeserver: config.homeserver,
        accessToken: credentials.accessToken,
        userId: credentials.userId,
        subscribeRooms: config.subscribeRooms,
        msgtypes: config.filters.msgtypes,
      });

      syncClient.on("message", async (message: MatrixMessage) => {
        if (dedupe.has(message.eventId)) return;
        dedupe.add(message.eventId);

        const roomLabel = config.roomLabels[message.roomId];
        const label = roomLabel || message.roomId;

        if (!message.isDirect && !messageMentionsIdentity(message.body, credentials.userId)) {
          return;
        }

        const injection = formatInjection(message, label);
        const sessionId = await getActiveSessionId(client, baseDir);

        if (!sessionId) {
          log("warn", "No active session available for Matrix injection", {
            roomId: message.roomId,
            sender: message.sender,
          });
          client.tui.showToast({
            body: { message: "Matrix: no active session", variant: "warning" },
          }).catch(() => undefined);
          return;
        }

        try {
          await client.session.prompt({
            path: { id: sessionId },
            body: {
              noReply: config.noReply,
              parts: [{ type: "text", text: injection }],
            },
          });
          log("info", "Injected Matrix message", {
            roomId: message.roomId,
            eventId: message.eventId,
            sessionId,
          });
        } catch (err: any) {
          log("error", "Failed to inject Matrix message", {
            error: err?.message || err,
            roomId: message.roomId,
            eventId: message.eventId,
          });
          client.tui.showToast({
            body: { message: `Matrix inject failed: ${err?.message || err}`, variant: "error" },
          }).catch(() => undefined);
        }
      });

      await syncClient.start();
      await syncClient.joinRooms();

      const sessionId = `opencode-${process.pid}-${Date.now()}`;
      bridgeRegistrationId = await registerWithBridge(baseDir, config.subscribeRooms, sessionId);
      if (bridgeRegistrationId) {
        heartbeatInterval = setInterval(() => {
          if (bridgeRegistrationId) {
            sendHeartbeat(bridgeRegistrationId).catch(() => undefined);
          }
        }, HEARTBEAT_INTERVAL_MS);
        log("info", "Registered with opencode-bridge", { registrationId: bridgeRegistrationId });
      }

      log("info", "Matrix context injector started", {
        userId: credentials.userId,
        rooms: config.subscribeRooms,
        configPath: config.configPath,
        credentialsOrigin: credentials.origin,
        bridgeRegistrationId,
      });
    } catch (error: any) {
      log("error", "Matrix context injector failed to start", {
        error: error?.message || error,
      });
      client.tui.showToast({
        body: { message: `Matrix injector error: ${error?.message || error}`, variant: "error" },
      }).catch(() => undefined);
      shutdown();
    }
  }, 2000);

  return {};
};
