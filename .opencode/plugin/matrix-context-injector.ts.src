import type { Plugin } from "@opencode-ai/plugin";
import { existsSync } from "fs";
import { mkdir, readFile, unlink, writeFile } from "fs/promises";
import path from "path";
import WebSocket from "ws";

const BRIDGE_URL = process.env.OPENCODE_BRIDGE_URL || "http://127.0.0.1:3201";
const BRIDGE_WS_URL = process.env.OPENCODE_BRIDGE_WS_URL || "ws://127.0.0.1:3201/ws";
const HEARTBEAT_INTERVAL_MS = 2 * 60 * 1000;
const WS_RECONNECT_BASE_MS = 1000;
const WS_RECONNECT_MAX_MS = 30000;

interface MatrixMessage {
  type: "matrix_message";
  sender: string;
  senderMxid: string;
  roomId: string;
  body: string;
  eventId: string;
}

interface OutboundMessage {
  type: "outbound_message";
  role: "assistant" | "user";
  content: string;
  messageId: string;
}

function getSessionUpdatedAtMs(session: any): number {
  const value = session?.time?.updated;
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
}

async function getActiveSessionId(client: any, targetDirectory: string): Promise<string | null> {
  try {
    const response = await client.session.list();
    const sessions = Array.isArray(response.data) ? response.data : [];

    const targetResolved = path.resolve(targetDirectory);
    const matching = sessions.filter((session: any) => {
      if (!session?.directory || typeof session.directory !== "string") return false;
      return path.resolve(session.directory) === targetResolved;
    });

    if (matching.length === 0) return null;

    const sorted = [...matching].sort(
      (a: any, b: any) => getSessionUpdatedAtMs(b) - getSessionUpdatedAtMs(a)
    );
    return sorted[0].id;
  } catch {
    return null;
  }
}

async function acquireLock(lockPath: string): Promise<void> {
  if (existsSync(lockPath)) {
    const contents = await readFile(lockPath, "utf-8").catch(() => "");
    if (contents) {
      try {
        const parsed = JSON.parse(contents) as { pid?: number };
        if (typeof parsed.pid === "number") {
          try {
            process.kill(parsed.pid, 0);
          } catch {
            await unlink(lockPath).catch(() => undefined);
          }
        }
      } catch {
      }
    }

    if (existsSync(lockPath)) {
      throw new Error(
        `Matrix bridge plugin already running. Remove lock at ${lockPath}. ${contents ? `Details: ${contents}` : ""}`
      );
    }
  }

  const payload = JSON.stringify({
    pid: process.pid,
    startedAt: new Date().toISOString(),
  });
  await writeFile(lockPath, payload, { flag: "wx" });
}

async function releaseLock(lockPath: string): Promise<void> {
  if (!existsSync(lockPath)) return;
  await unlink(lockPath).catch(() => undefined);
}

async function registerWithBridge(
  directory: string,
  sessionId: string,
  roomId?: string | null
): Promise<{ id: string; wsUrl: string } | null> {
  try {
    const rooms = roomId ? [roomId] : [];
    const response = await fetch(`${BRIDGE_URL}/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        sessionId,
        directory,
        rooms,
      }),
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { id?: string; wsUrl?: string };
    if (!data.id) return null;
    return { id: data.id, wsUrl: data.wsUrl || BRIDGE_WS_URL };
  } catch {
    return null;
  }
}

async function sendHeartbeat(registrationId: string): Promise<boolean> {
  try {
    const response = await fetch(`${BRIDGE_URL}/heartbeat`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
    return response.ok;
  } catch {
    return false;
  }
}

async function unregisterFromBridge(registrationId: string): Promise<void> {
  try {
    await fetch(`${BRIDGE_URL}/unregister`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
  } catch {
  }
}

async function ensureMatrixRoom(directory: string): Promise<string | null> {
  const MCP_URL = process.env.MATRIX_MCP_URL || "http://127.0.0.1:3103";
  try {
    const response = await fetch(`${MCP_URL}/mcp`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "tools/call",
        params: {
          name: "matrix_messaging",
          arguments: {
            operation: "opencode_connect",
            directory,
            caller_directory: directory,
          }
        },
        id: Date.now()
      }),
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { 
      result?: { content?: Array<{ text?: string }> };
      error?: { message?: string };
    };
    if (data.error) {
      console.error(`[MatrixPlugin] ensureMatrixRoom error: ${data.error.message}`);
      return null;
    }
    const text = data.result?.content?.[0]?.text;
    if (!text) return null;
    try {
      const parsed = JSON.parse(text) as { room_id?: string };
      return parsed.room_id || null;
    } catch {
      return null;
    }
  } catch (err) {
    console.error(`[MatrixPlugin] ensureMatrixRoom failed:`, err);
    return null;
  }
}

export const MatrixContextInjector: Plugin = async ({ client, directory, worktree }) => {
  const baseDir = worktree || directory;
  const opencodeDirPath = path.join(baseDir, ".opencode");
  const lockPath = path.join(opencodeDirPath, "matrix.lock");

  if (!existsSync(opencodeDirPath)) {
    await mkdir(opencodeDirPath, { recursive: true });
  }



  let bridgeRegistrationId: string | null = null;
  let heartbeatInterval: NodeJS.Timeout | null = null;
  let ws: WebSocket | null = null;
  let wsReconnectAttempts = 0;
  let wsReconnectTimeout: NodeJS.Timeout | null = null;
  let shuttingDown = false;
  const pendingMessages = new Map<string, { content: string; sentLength: number; timer: NodeJS.Timeout | null }>();
  const STREAM_SETTLE_MS = 500;
  
  const sendOutboundMessage = (role: "assistant" | "user", content: string, messageId: string) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    
    const outbound: OutboundMessage = {
      type: "outbound_message",
      role,
      content,
      messageId,
    };
    
    try {
      ws.send(JSON.stringify(outbound));
    } catch {
    }
  };
  
  const scheduleOutboundSend = (messageId: string, content: string, role: "assistant" | "user") => {
    let entry = pendingMessages.get(messageId);
    
    if (!entry) {
      entry = { content: "", sentLength: 0, timer: null };
      pendingMessages.set(messageId, entry);
    }
    
    entry.content = content;
    
    if (entry.timer) {
      clearTimeout(entry.timer);
    }
    
    entry.timer = setTimeout(() => {
      const e = pendingMessages.get(messageId);
      if (e && e.content.length > e.sentLength) {
        sendOutboundMessage(role, e.content, messageId);
        e.sentLength = e.content.length;
      }
    }, STREAM_SETTLE_MS);
    
    if (pendingMessages.size > 100) {
      const staleKeys = Array.from(pendingMessages.keys()).slice(0, 50);
      staleKeys.forEach(k => {
        const e = pendingMessages.get(k);
        if (e?.timer) clearTimeout(e.timer);
        pendingMessages.delete(k);
      });
    }
  };

  const shutdown = () => {
    shuttingDown = true;
    if (wsReconnectTimeout) {
      clearTimeout(wsReconnectTimeout);
      wsReconnectTimeout = null;
    }
    if (ws) {
      ws.close();
      ws = null;
    }
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
    if (bridgeRegistrationId) {
      unregisterFromBridge(bridgeRegistrationId).catch(() => undefined);
      bridgeRegistrationId = null;
    }
    releaseLock(lockPath).catch(() => undefined);
  };

  const connectWebSocket = (wsUrl: string, registrationId: string) => {
    if (shuttingDown) return;

    ws = new WebSocket(wsUrl);

    ws.on("open", () => {
      wsReconnectAttempts = 0;
      ws?.send(JSON.stringify({ type: "auth", registrationId }));
    });

    ws.on("message", async (data) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === "auth_success" || message.type === "auth_error") {
          return;
        }

        if (message.type === "matrix_message") {
          const matrixMsg = message as MatrixMessage;
          
          if (matrixMsg.body.startsWith("**User:**") || matrixMsg.body.startsWith("**Emmanuel:**")) {
            return;
          }
          
          const sessionId = await getActiveSessionId(client, baseDir);
          if (!sessionId) return;

          const injection = `[Matrix from ${matrixMsg.sender} in ${matrixMsg.roomId}]\n${matrixMsg.body}`;

          try {
            await client.tui.appendPrompt({ body: { text: injection } });
            await client.tui.submitPrompt();
          } catch {
          }
        }
      } catch {
      }
    });

    ws.on("close", () => {
      if (shuttingDown) return;
      scheduleReconnect(wsUrl, registrationId);
    });

    ws.on("error", () => {
    });
  };

  const scheduleReconnect = (wsUrl: string, registrationId: string) => {
    if (shuttingDown || wsReconnectTimeout) return;

    wsReconnectAttempts++;
    const delay = Math.min(
      WS_RECONNECT_BASE_MS * Math.pow(2, wsReconnectAttempts - 1),
      WS_RECONNECT_MAX_MS
    );

    wsReconnectTimeout = setTimeout(() => {
      wsReconnectTimeout = null;
      connectWebSocket(wsUrl, registrationId);
    }, delay);
  };

  process.on("exit", shutdown);
  process.on("SIGINT", () => {
    shutdown();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    shutdown();
    process.exit(0);
  });

  setTimeout(async () => {
    try {
      await acquireLock(lockPath);
    } catch {
      return;
    }

    try {
      const sessionId = `opencode-${process.pid}-${Date.now()}`;
      
      const roomId = await ensureMatrixRoom(baseDir);
      if (roomId) {
        console.log(`[MatrixPlugin] Room ensured: ${roomId}`);
      }
      
      const result = await registerWithBridge(baseDir, sessionId, roomId);

      if (result) {
        bridgeRegistrationId = result.id;

        heartbeatInterval = setInterval(() => {
          if (bridgeRegistrationId) {
            sendHeartbeat(bridgeRegistrationId).catch(() => undefined);
          }
        }, HEARTBEAT_INTERVAL_MS);

        connectWebSocket(result.wsUrl, result.id);
      }
    } catch {
      shutdown();
    }
  }, 2000);

  const messagePartsMap = new Map<string, Map<string, string>>();
  const sentMessages = new Set<string>();
  const sentUserMessages = new Set<string>();
  
  return {
    "chat.message": async (input: any, output: any) => {
      const userMsg = input?.message;
      if (!userMsg) return;
      
      let content: string | null = null;
      if (typeof userMsg === 'string') {
        content = userMsg;
      } else if (userMsg.content && typeof userMsg.content === 'string') {
        content = userMsg.content;
      } else if (userMsg.parts && Array.isArray(userMsg.parts)) {
        content = userMsg.parts
          .filter((p: any) => p.type === 'text' && p.text)
          .map((p: any) => p.text)
          .join('\n');
      }
      
      if (!content || !content.trim()) return;
      
      if (content.includes("[Matrix from ")) return;
      
      const messageId = `user-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      sendOutboundMessage("user", content, messageId);
      
      const contentHash = content.trim().substring(0, 100);
      sentUserMessages.add(contentHash);
      
      if (sentUserMessages.size > 50) {
        const oldest = Array.from(sentUserMessages).slice(0, 25);
        oldest.forEach(h => sentUserMessages.delete(h));
      }
    },
    
    event: async ({ event }: { event: any }) => {
      if (event.type === "message.part.updated") {
        const part = event.properties?.part;
        if (!part || part.type !== "text") return;
        
        const { messageID, id: partId, text } = part;
        if (!messageID || !partId || typeof text !== "string") return;
        
        let msgParts = messagePartsMap.get(messageID);
        if (!msgParts) {
          msgParts = new Map<string, string>();
          messagePartsMap.set(messageID, msgParts);
        }
        msgParts.set(partId, text);
      }
      
      if (event.type === "session.idle") {
        for (const [messageID, parts] of messagePartsMap.entries()) {
          if (sentMessages.has(messageID)) continue;
          
          const fullContent = Array.from(parts.values()).join("\n");
          
          if (fullContent.includes("[Matrix from ")) continue;
          
          if (fullContent.trim() && fullContent.length > 20) {
            sendOutboundMessage("assistant", fullContent, messageID);
            sentMessages.add(messageID);
          }
        }
        
        messagePartsMap.clear();
      }
      
      if (sentMessages.size > 100) {
        const oldest = Array.from(sentMessages).slice(0, 50);
        oldest.forEach(id => sentMessages.delete(id));
      }
    },
  };
};

export default MatrixContextInjector;
