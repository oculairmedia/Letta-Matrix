import type { Plugin } from "@opencode-ai/plugin";
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from "fs";
import { mkdir, readFile, unlink, writeFile } from "fs/promises";
import path from "path";
import os from "os";
import WebSocket from "ws";

const BRIDGE_URL = process.env.OPENCODE_BRIDGE_URL || "http://127.0.0.1:3201";
const BRIDGE_WS_URL = process.env.OPENCODE_BRIDGE_WS_URL || "ws://127.0.0.1:3201/ws";
const HEARTBEAT_INTERVAL_MS = 2 * 60 * 1000;
const WS_RECONNECT_BASE_MS = 1000;
const WS_RECONNECT_MAX_MS = 30000;
const MESSAGE_INJECT_TIMEOUT_MS = 10_000; // 10s — if session.idle hasn't fired, inject anyway

// Debug logging to file since console.log doesn't appear in OpenCode logs
const DEBUG_LOG_PATH = path.join(os.homedir(), ".local", "share", "opencode", "matrix-plugin-debug.log");
function debugLog(message: string): void {
  const timestamp = new Date().toISOString();
  const line = `[${timestamp}] ${message}\n`;
  try {
    writeFileSync(DEBUG_LOG_PATH, line, { flag: 'a' });
  } catch {
    // Ignore write errors
  }
}

// Storage paths - matching OpenCode's xdg-basedir behavior
function getDataDir(): string {
  return process.env.XDG_DATA_HOME ?? path.join(os.homedir(), ".local", "share");
}

function getOpenCodeStorageDir(): string {
  return path.join(getDataDir(), "opencode", "storage");
}

const OPENCODE_STORAGE = getOpenCodeStorageDir();
const MESSAGE_STORAGE = path.join(OPENCODE_STORAGE, "message");
const PART_STORAGE = path.join(OPENCODE_STORAGE, "part");

interface MatrixMessage {
  type: "matrix_message";
  sender: string;
  senderMxid: string;
  roomId: string;
  body: string;
  eventId: string;
}

interface OutboundMessage {
  type: "outbound_message";
  role: "assistant" | "user";
  content: string;
  messageId: string;
}

interface MessageMeta {
  id: string;
  sessionID: string;
  role: "user" | "assistant";
  time: { created: number; completed?: number };
  agent?: string;
  model?: { providerID: string; modelID: string };
  path?: { cwd: string; root: string };
}

interface TextPart {
  id: string;
  type: "text";
  text: string;
  synthetic: boolean;
  time: { start: number; end: number };
  messageID: string;
  sessionID: string;
}

function generateMessageId(): string {
  const timestamp = Date.now().toString(16);
  const random = Math.random().toString(36).substring(2, 14);
  return `msg_${timestamp}${random}`;
}

function generatePartId(): string {
  const timestamp = Date.now().toString(16);
  const random = Math.random().toString(36).substring(2, 10);
  return `prt_${timestamp}${random}`;
}

function getOrCreateMessageDir(sessionID: string): string {
  if (!existsSync(MESSAGE_STORAGE)) {
    mkdirSync(MESSAGE_STORAGE, { recursive: true });
  }

  const directPath = path.join(MESSAGE_STORAGE, sessionID);
  if (existsSync(directPath)) {
    return directPath;
  }

  // Check nested directories
  try {
    for (const dir of readdirSync(MESSAGE_STORAGE)) {
      const sessionPath = path.join(MESSAGE_STORAGE, dir, sessionID);
      if (existsSync(sessionPath)) {
        return sessionPath;
      }
    }
  } catch {
    // Ignore errors
  }

  mkdirSync(directPath, { recursive: true });
  return directPath;
}

interface StoredMessage {
  agent?: string;
  model?: { providerID?: string; modelID?: string };
}

function findNearestMessageWithFields(messageDir: string): StoredMessage | null {
  try {
    const files = readdirSync(messageDir)
      .filter((f) => f.endsWith(".json"))
      .sort()
      .reverse();

    for (const file of files) {
      try {
        const content = readFileSync(path.join(messageDir, file), "utf-8");
        const msg = JSON.parse(content) as StoredMessage;
        if (msg.agent || (msg.model?.providerID && msg.model?.modelID)) {
          return msg;
        }
      } catch {
        continue;
      }
    }
  } catch {
    return null;
  }
  return null;
}

function injectMessage(sessionID: string, text: string, cwd?: string): boolean {
  if (!text || text.trim().length === 0) {
    console.log("[MatrixPlugin] Attempted to inject empty message, skipping");
    return false;
  }

  const messageDir = getOrCreateMessageDir(sessionID);
  const fallback = findNearestMessageWithFields(messageDir);

  const now = Date.now();
  const messageID = generateMessageId();
  const partID = generatePartId();

  const messageMeta: MessageMeta = {
    id: messageID,
    sessionID,
    role: "user",
    time: { created: now },
    agent: fallback?.agent ?? "general",
    model: fallback?.model?.providerID && fallback?.model?.modelID
      ? { providerID: fallback.model.providerID, modelID: fallback.model.modelID }
      : undefined,
    path: cwd ? { cwd, root: "/" } : undefined,
  };

  const textPart: TextPart = {
    id: partID,
    type: "text",
    text,
    synthetic: true,
    time: { start: now, end: now },
    messageID,
    sessionID,
  };

  try {
    writeFileSync(path.join(messageDir, `${messageID}.json`), JSON.stringify(messageMeta, null, 2));

    const partDir = path.join(PART_STORAGE, messageID);
    if (!existsSync(partDir)) {
      mkdirSync(partDir, { recursive: true });
    }
    writeFileSync(path.join(partDir, `${partID}.json`), JSON.stringify(textPart, null, 2));

    console.log(`[MatrixPlugin] Injected message ${messageID} into session ${sessionID}`);
    return true;
  } catch (err) {
    console.error(`[MatrixPlugin] Failed to inject message:`, err);
    return false;
  }
}

function getSessionUpdatedAtMs(session: any): number {
  const value = session?.time?.updated;
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
}

async function getActiveSessionId(client: any, targetDirectory: string): Promise<string | null> {
  try {
    const response = await client.session.list();
    const sessions = Array.isArray(response.data) ? response.data : [];

    const targetResolved = path.resolve(targetDirectory);
    const matching = sessions.filter((session: any) => {
      if (!session?.directory || typeof session.directory !== "string") return false;
      return path.resolve(session.directory) === targetResolved;
    });

    if (matching.length === 0) return null;

    const sorted = [...matching].sort(
      (a: any, b: any) => getSessionUpdatedAtMs(b) - getSessionUpdatedAtMs(a)
    );
    return sorted[0].id;
  } catch {
    return null;
  }
}

async function acquireLock(lockPath: string): Promise<void> {
  if (existsSync(lockPath)) {
    const contents = await readFile(lockPath, "utf-8").catch(() => "");
    if (contents) {
      try {
        const parsed = JSON.parse(contents) as { pid?: number };
        if (typeof parsed.pid === "number") {
          try {
            process.kill(parsed.pid, 0);
          } catch {
            await unlink(lockPath).catch(() => undefined);
          }
        }
      } catch {
      }
    }

    if (existsSync(lockPath)) {
      throw new Error(
        `Matrix bridge plugin already running. Remove lock at ${lockPath}. ${contents ? `Details: ${contents}` : ""}`
      );
    }
  }

  const payload = JSON.stringify({
    pid: process.pid,
    startedAt: new Date().toISOString(),
  });
  await writeFile(lockPath, payload, { flag: "wx" });
}

async function releaseLock(lockPath: string): Promise<void> {
  if (!existsSync(lockPath)) return;
  await unlink(lockPath).catch(() => undefined);
}

async function registerWithBridge(
  directory: string,
  sessionId: string,
  roomId?: string | null
): Promise<{ id: string; wsUrl: string } | null> {
  try {
    const rooms = roomId ? [roomId] : [];
    const response = await fetch(`${BRIDGE_URL}/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        sessionId,
        directory,
        rooms,
      }),
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { id?: string; wsUrl?: string };
    if (!data.id) return null;
    return { id: data.id, wsUrl: data.wsUrl || BRIDGE_WS_URL };
  } catch {
    return null;
  }
}

async function sendHeartbeat(registrationId: string): Promise<boolean> {
  try {
    const response = await fetch(`${BRIDGE_URL}/heartbeat`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
    return response.ok;
  } catch {
    return false;
  }
}

async function unregisterFromBridge(registrationId: string): Promise<void> {
  try {
    await fetch(`${BRIDGE_URL}/unregister`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: registrationId }),
    });
  } catch {
  }
}

async function ensureMatrixRoom(directory: string): Promise<string | null> {
  const MCP_URL = process.env.MATRIX_MCP_URL || "http://127.0.0.1:3103";
  try {
    const response = await fetch(`${MCP_URL}/mcp`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "tools/call",
        params: {
          name: "matrix_messaging",
          arguments: {
            operation: "opencode_connect",
            directory,
            caller_directory: directory,
          }
        },
        id: Date.now()
      }),
    });
    if (!response.ok) return null;
    const data = (await response.json()) as { 
      result?: { content?: Array<{ text?: string }> };
      error?: { message?: string };
    };
    if (data.error) {
      console.error(`[MatrixPlugin] ensureMatrixRoom error: ${data.error.message}`);
      return null;
    }
    const text = data.result?.content?.[0]?.text;
    if (!text) return null;
    try {
      const parsed = JSON.parse(text) as { room_id?: string };
      return parsed.room_id || null;
    } catch {
      return null;
    }
  } catch (err) {
    console.error(`[MatrixPlugin] ensureMatrixRoom failed:`, err);
    return null;
  }
}

export const MatrixContextInjector: Plugin = async ({ client, directory, worktree }) => {
  const baseDir = worktree || directory;
  const opencodeDirPath = path.join(baseDir, ".opencode");
  const lockPath = path.join(opencodeDirPath, "matrix.lock");

  debugLog(`=== MatrixContextInjector initializing ===`);
  debugLog(`baseDir: ${baseDir}`);
  debugLog(`PID: ${process.pid}`);

  if (!existsSync(opencodeDirPath)) {
    await mkdir(opencodeDirPath, { recursive: true });
  }



  let bridgeRegistrationId: string | null = null;
  let heartbeatInterval: NodeJS.Timeout | null = null;
  let ws: WebSocket | null = null;
  let wsReconnectAttempts = 0;
  let wsReconnectTimeout: NodeJS.Timeout | null = null;
  let shuttingDown = false;
  const pendingMessages = new Map<string, { content: string; sentLength: number; timer: NodeJS.Timeout | null }>();
  // (STREAM_SETTLE_MS removed — scheduleOutboundSend was dead code, outbound messages use sendOutboundMessage directly)
  
  // Queue for incoming Matrix messages - inject on session.idle
  const pendingMatrixMessages: Array<{
    sender: string;
    senderMxid: string;
    roomId: string;
    body: string;
    eventId: string;
    receivedAt: number;
  }> = [];
  const processedEventIds = new Set<string>();
  let injectTimeout: NodeJS.Timeout | null = null;
  
  // Shared function: inject all queued Matrix messages into the active session
  // Called from both session.idle handler and the fallback timeout
  const injectPendingMessages = async (sessionId: string, trigger: string): Promise<void> => {
    const count = pendingMatrixMessages.length;
    if (count === 0) return;
    debugLog(`injectPendingMessages (${trigger}): processing ${count} queued messages for session ${sessionId}`);
    
    const messageDir = getOrCreateMessageDir(sessionId);
    const prevMessage = findNearestMessageWithFields(messageDir);
    
    // Combine all pending messages into one injection
    const combinedMessages = pendingMatrixMessages
      .filter(msg => !processedEventIds.has(msg.eventId))
      .map(msg => `[Matrix from ${msg.sender} in ${msg.roomId}]\n${msg.body}`)
      .join("\n\n---\n\n");
    
    if (!combinedMessages.trim()) {
      pendingMatrixMessages.length = 0;
      return;
    }
    
    // Mark all as processed
    pendingMatrixMessages.forEach(msg => processedEventIds.add(msg.eventId));
    pendingMatrixMessages.length = 0;
    
    // Limit processed set size
    if (processedEventIds.size > 200) {
      const toRemove = Array.from(processedEventIds).slice(0, 100);
      toRemove.forEach(id => processedEventIds.delete(id));
    }
    
    try {
      debugLog(`Attempting session.prompt (${trigger}) with sessionId=${sessionId}, agent=${prevMessage?.agent || 'none'}`);
      debugLog(`Combined message content: ${combinedMessages.substring(0, 200)}...`);
      await client.session.prompt({
        path: { id: sessionId },
        body: {
          agent: prevMessage?.agent,
          parts: [{ type: "text", text: combinedMessages }],
        },
        query: { directory: baseDir },
      });
      debugLog(`SUCCESS (${trigger}): Injected queued messages via session.prompt`);
    } catch (e: any) {
      debugLog(`FAILED (${trigger}): session.prompt error: ${e?.message || e}`);
      // Fallback to file-based injection
      const fallbackResult = injectMessage(sessionId, combinedMessages, baseDir);
      debugLog(`Fallback file-based injection result (${trigger}): ${fallbackResult}`);
    }
  };
  
  const sendOutboundMessage = (role: "assistant" | "user", content: string, messageId: string) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    
    const outbound: OutboundMessage = {
      type: "outbound_message",
      role,
      content,
      messageId,
    };
    
    try {
      ws.send(JSON.stringify(outbound));
    } catch {
    }
  };
  
  // scheduleOutboundSend removed — was dead code (never called).
  // Outbound messages go through sendOutboundMessage() directly.

  const shutdown = () => {
    shuttingDown = true;
    if (injectTimeout) {
      clearTimeout(injectTimeout);
      injectTimeout = null;
    }
    if (wsReconnectTimeout) {
      clearTimeout(wsReconnectTimeout);
      wsReconnectTimeout = null;
    }
    if (ws) {
      ws.close();
      ws = null;
    }
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
    if (bridgeRegistrationId) {
      unregisterFromBridge(bridgeRegistrationId).catch(() => undefined);
      bridgeRegistrationId = null;
    }
    releaseLock(lockPath).catch(() => undefined);
  };

  // Store the initial session ID to reuse on reconnects (prevents bridge cleanup loop)
  let currentSessionId = `opencode-${process.pid}-${Date.now()}`;
  
  const reRegisterAndReconnect = async (wsUrl: string) => {
    if (shuttingDown) return;
    debugLog("Re-registering with bridge...");
    const roomId = await ensureMatrixRoom(baseDir).catch(() => null);
    // IMPORTANT: Reuse the same session ID to avoid bridge cleanup loop
    const result = await registerWithBridge(baseDir, currentSessionId, roomId);
    if (result) {
      bridgeRegistrationId = result.id;
      debugLog(`Re-registered with bridge as: ${result.id}`);
      connectWebSocket(result.wsUrl || wsUrl, result.id);
    } else {
      debugLog("Re-registration failed, scheduling retry...");
      scheduleReconnect(wsUrl, bridgeRegistrationId || "");
    }
  };

  const connectWebSocket = (wsUrl: string, registrationId: string) => {
    if (shuttingDown) return;

    ws = new WebSocket(wsUrl);

    ws.on("open", () => {
      wsReconnectAttempts = 0;
      debugLog(`WebSocket opened, sending auth for registrationId: ${registrationId}`);
      ws?.send(JSON.stringify({ type: "auth", registrationId }));
    });

    ws.on("message", async (data) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === "auth_success") {
          debugLog("WebSocket authenticated successfully");
          return;
        }
        if (message.type === "auth_error") {
          debugLog("WebSocket auth failed, re-registering...");
          ws?.close();
          reRegisterAndReconnect(wsUrl);
          return;
        }

        if (message.type === "matrix_message") {
          const matrixMsg = message as MatrixMessage;
          debugLog(`Received matrix_message from ${matrixMsg.sender}: ${matrixMsg.body.substring(0, 50)}...`);
          
          if (matrixMsg.body.startsWith("**User:**") || matrixMsg.body.startsWith("**Emmanuel:**")) {
            debugLog(`Skipping echo message`);
            return;
          }
          
          // Skip if already processed
          if (processedEventIds.has(matrixMsg.eventId)) {
            debugLog(`Skipping already processed eventId: ${matrixMsg.eventId}`);
            return;
          }
          
          // Queue the message for injection on session.idle
          pendingMatrixMessages.push({
            sender: matrixMsg.sender,
            senderMxid: matrixMsg.senderMxid,
            roomId: matrixMsg.roomId,
            body: matrixMsg.body,
            eventId: matrixMsg.eventId,
            receivedAt: Date.now(),
          });
          
          debugLog(`Queued message from ${matrixMsg.sender} (${pendingMatrixMessages.length} pending)`);
          
          // Start a timeout — if session.idle doesn't fire within 10s, inject anyway
          if (!injectTimeout) {
            injectTimeout = setTimeout(async () => {
              injectTimeout = null;
              if (pendingMatrixMessages.length === 0) return;
              debugLog(`Inject timeout fired — session.idle hasn't processed ${pendingMatrixMessages.length} messages in ${MESSAGE_INJECT_TIMEOUT_MS}ms`);
              const sessionId = await getActiveSessionId(client, baseDir);
              if (sessionId) {
                await injectPendingMessages(sessionId, 'timeout');
              } else {
                debugLog(`Inject timeout: no active session found, messages remain queued`);
              }
            }, MESSAGE_INJECT_TIMEOUT_MS);
          }
        }
      } catch {
      }
    });

    ws.on("close", (code, reason) => {
      debugLog(`WebSocket closed: code=${code}, reason=${reason?.toString() || 'none'}`);
      if (shuttingDown) return;
      scheduleReconnect(wsUrl, registrationId);
    });

    ws.on("error", (err) => {
      debugLog(`WebSocket error: ${err?.message || err}`);
    });
  };

  const scheduleReconnect = (wsUrl: string, registrationId: string) => {
    if (shuttingDown || wsReconnectTimeout) return;

    wsReconnectAttempts++;
    const delay = Math.min(
      WS_RECONNECT_BASE_MS * Math.pow(2, wsReconnectAttempts - 1),
      WS_RECONNECT_MAX_MS
    );

    debugLog(`Scheduling reconnect in ${delay}ms (attempt ${wsReconnectAttempts})`);
    wsReconnectTimeout = setTimeout(() => {
      wsReconnectTimeout = null;
      reRegisterAndReconnect(wsUrl);
    }, delay);
  };

  process.on("exit", shutdown);
  process.on("SIGINT", () => {
    shutdown();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    shutdown();
    process.exit(0);
  });

  // Initial registration after short delay (non-blocking — must use setTimeout per OpenCode plugin pattern)
  setTimeout(async () => {
    try {
      await acquireLock(lockPath);
    } catch (lockErr: any) {
      debugLog(`Lock acquisition failed: ${lockErr?.message || lockErr}`);
      return;
    }

    try {
      const roomId = await ensureMatrixRoom(baseDir);
      if (roomId) {
        debugLog(`Room ensured: ${roomId}`);
      }
      
      const result = await registerWithBridge(baseDir, currentSessionId, roomId);

      if (result) {
        bridgeRegistrationId = result.id;
        debugLog(`Registered with bridge as: ${result.id}`);

        heartbeatInterval = setInterval(() => {
          if (bridgeRegistrationId) {
            sendHeartbeat(bridgeRegistrationId).catch(() => undefined);
          }
        }, HEARTBEAT_INTERVAL_MS);

        connectWebSocket(result.wsUrl, result.id);
      } else {
        debugLog(`Bridge registration failed - no result`);
      }
    } catch (err: any) {
      debugLog(`Bridge registration error: ${err?.message || err}`);
      shutdown();
    }
  }, 500);

  const messagePartsMap = new Map<string, Map<string, string>>();
  const sentMessages = new Set<string>();
  const sentUserMessages = new Set<string>();
  
  return {
    "chat.message": async (input: any, output: any) => {
      const userMsg = input?.message;
      if (!userMsg) return;
      
      let content: string | null = null;
      if (typeof userMsg === 'string') {
        content = userMsg;
      } else if (userMsg.content && typeof userMsg.content === 'string') {
        content = userMsg.content;
      } else if (userMsg.parts && Array.isArray(userMsg.parts)) {
        content = userMsg.parts
          .filter((p: any) => p.type === 'text' && p.text)
          .map((p: any) => p.text)
          .join('\n');
      }
      
      if (!content || !content.trim()) return;
      
      if (content.includes("[Matrix from ")) return;
      
      const messageId = `user-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      sendOutboundMessage("user", content, messageId);
      
      const contentHash = content.trim().substring(0, 100);
      sentUserMessages.add(contentHash);
      
      if (sentUserMessages.size > 50) {
        const oldest = Array.from(sentUserMessages).slice(0, 25);
        oldest.forEach(h => sentUserMessages.delete(h));
      }
    },
    
    event: async ({ event }: { event: any }) => {
      if (event.type === "message.part.updated") {
        const part = event.properties?.part;
        if (!part || part.type !== "text") return;
        
        const { messageID, id: partId, text } = part;
        if (!messageID || !partId || typeof text !== "string") return;
        
        let msgParts = messagePartsMap.get(messageID);
        if (!msgParts) {
          msgParts = new Map<string, string>();
          messagePartsMap.set(messageID, msgParts);
        }
        msgParts.set(partId, text);
      }
      
      if (event.type === "session.idle") {
        debugLog(`session.idle event received. Properties: ${JSON.stringify(event.properties || {})}`);
        let sessionId = event.properties?.sessionID as string | undefined;
        
        // Fallback: get active session if not in event
        if (!sessionId) {
          debugLog(`No sessionID in event, trying getActiveSessionId...`);
          sessionId = await getActiveSessionId(client, baseDir);
          debugLog(`getActiveSessionId returned: ${sessionId || 'null'}`);
        }
        
        // Process queued Matrix messages
        debugLog(`Pending messages: ${pendingMatrixMessages.length}, sessionId: ${sessionId || 'null'}`);
        if (pendingMatrixMessages.length > 0 && sessionId) {
          // session.idle fired — cancel the fallback timeout since we're handling it now
          if (injectTimeout) {
            clearTimeout(injectTimeout);
            injectTimeout = null;
          }
          await injectPendingMessages(sessionId, 'session.idle');
        }
        
        // Original outbound message handling
        for (const [messageID, parts] of messagePartsMap.entries()) {
          if (sentMessages.has(messageID)) continue;
          
          const fullContent = Array.from(parts.values()).join("\n");
          
          if (fullContent.includes("[Matrix from ")) continue;
          
          if (fullContent.trim() && fullContent.length > 20) {
            sendOutboundMessage("assistant", fullContent, messageID);
            sentMessages.add(messageID);
          }
        }
        
        messagePartsMap.clear();
      }
      
      if (sentMessages.size > 100) {
        const oldest = Array.from(sentMessages).slice(0, 50);
        oldest.forEach(id => sentMessages.delete(id));
      }
    },
  };
};

export default MatrixContextInjector;
